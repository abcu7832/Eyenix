module MtoN_async_fifo #(
    parameter WIDTH      = 8,
    parameter DEPTH      = 8,
    parameter PFULL_TH   = 10,
    parameter PEMPTY_TH  = 10,
    parameter M_WRITERS  = 2,
    parameter N_READERS  = 2
)(
    // ----------------------------------------------------------------
    // write side (wr_clk domain)
    // ----------------------------------------------------------------
    input logic                        i_wr_clk,
    input logic                        i_wr_rstn,
    input logic [M_WRITERS-1:0]        i_wr_en,

    output logic                       o_wr_full,
    output logic                       o_wr_afull,
    output logic                       o_wr_pfull,
    output logic [DEPTH:0]             o_wr_remain,

    input logic [M_WRITERS*WIDTH-1:0]  i_wr_data,
    output logic [M_WRITERS-1:0]       o_wr_ed,

    // ----------------------------------------------------------------
    // read side (rd_clk domain)
    // ----------------------------------------------------------------
    input logic                        i_rd_clk,
    input logic                        i_rd_rstn,
    input logic [N_READERS-1:0]        i_rd_en,

    output logic                       o_rd_empty,
    output logic                       o_rd_aempty,
    output logic                       o_rd_pempty,
    output logic [DEPTH:0]             o_rd_depth,

    output logic [N_READERS*WIDTH-1:0] o_rd_data,
    output logic [N_READERS-1:0]       o_rd_valid
);
    //wr_data[FIFO_MEM_SIZE-1:M_WRITERS*WIDTH]는 유효한 데이터인지 파악하기 위함
    //localparam WRITE_IDX_WIDTH = (M_WRITERS <= 1) ? 1 : $clog2(M_WRITERS);
    localparam FIFO_MEM_SIZE = M_WRITERS*WIDTH + M_WRITERS;
    
    //localparam FIFO_MEM_SIZE = M_WRITERS*WIDTH;
    // =========================================================================
    // WRITE control (wr_clk)
    // =========================================================================
    logic                       winc;  // 1:1 async fifo로 전달됨.
    //logic [M_WRITERS*WIDTH-1:0] wr_data; // 1:1 async fifo로 전달됨.
    logic [FIFO_MEM_SIZE-1:0] wr_data; // 1:1 async fifo로 전달됨.

    // fifo memory가 안 차있고, writer가 push 신호를 보내면 wr_req는 high
    wire [M_WRITERS-1:0] wr_req = i_wr_en & {M_WRITERS{~o_wr_full}};

    assign o_wr_ed = wr_req;

    integer wk;
    always_comb begin
        winc    = 1'b0;
        wr_data = 0;
        // MUX
        for (wk=0; wk<M_WRITERS; wk=wk+1) begin
            // wr_req = i_wr_en & {M_WRITERS{~o_wr_full}}
            if (wr_req[wk]) begin
                winc = 1'b1;
                wr_data[wk*WIDTH +: WIDTH] = i_wr_data[wk*WIDTH +: WIDTH];
            end
        end
        wr_data[FIFO_MEM_SIZE-1:BIGGER] = wr_req;
    end

    // =========================================================================
    // READ control (rd_clk)
    // =========================================================================
    localparam READ_IDX_WIDTH = (N_READERS <= 1) ? 1 : $clog2(N_READERS);
    logic rinc;// fifo memory에 연결
    logic [FIFO_MEM_SIZE:0] rd_data;

    wire [N_READERS-1:0] rd_req = i_rd_en & {N_READERS{~o_rd_empty}};

    assign o_rd_data  = rd_data_regs;
    assign o_rd_valid = rd_valid_regs;
    
    logic [M_WRITERS*WIDTH-1:0] register_fifomem_to_read;
    logic [M_WRITERS-1:0] valid_data_status;

    logic [READ_IDX_WIDTH-1:0] read_idx;

    always_ff @(posedge i_rd_clk or negedge i_rd_rstn) begin
        if (!i_rd_rstn) begin
            register_fifomem_to_read <= 0;
            valid_data_status <= 0;
        end else begin
            if () begin // fifo mem에서 팝한 경우
                register_fifomem_to_read <= rd_data[M_WRITERS*WIDTH-1:0];
                valid_data_status <= rd_data[FIFO_MEM_SIZE-1:M_WRITER*WIDTH];
            end
        end
    end

    always_ff @(posedge i_rd_clk or negedge i_rd_rstn) begin
        if (!i_rd_rstn) begin
            o_rd_data <= 0;
        end else begin
            if (rd_req[read_idx]) begin
                o_rd_data[read_idx*WIDTH +: WIDTH] <= register_fifomem_to_read;
            end
        end
    end

    always_comb begin
        
    end
    // =========================================================================
    // 1:1 async FIFO 
    // =========================================================================

    logic [DEPTH-1:0] waddr;
    logic [DEPTH-1:0] raddr;
    logic [DEPTH:0]   wptr;
    logic [DEPTH:0]   rptr;
    logic [DEPTH:0]   wrptr2;
    logic [DEPTH:0]   rwptr2;

    wptr_full #(
        .DEPTH    (DEPTH),
        .PFULL_TH (PFULL_TH)
    ) u_wptr_full (
        .wclk        (i_wr_clk),
        .wrst_n      (i_wr_rstn),
        .winc        (winc),
        .wfull       (o_wr_full),
        .afull       (o_wr_afull),
        .pfull       (o_wr_pfull),
        .waddr       (waddr),
        .wptr        (wptr),
        .rwptr2      (rwptr2),
        .o_wr_remain (o_wr_remain)
    );

    sync #(.DEPTH(DEPTH)) u_sync_r2w (
        .clk   (i_wr_clk),
        .rst_n (i_wr_rstn),
        .ptr   (rptr),
        .ptr2  (rwptr2)
    );

    FIFO_Memory #(
        .WIDTH(FIFO_MEM_SIZE),
        .DEPTH(DEPTH)
    ) u_mem (
        .wclk   (i_wr_clk),
        .wdata  (wr_data),
        .wclken (winc && ~o_wr_full),
        .waddr  (waddr),
        .rdata  (rd_data),
        .raddr  (raddr)
    );

    sync #(.DEPTH(DEPTH)) u_sync_w2r (
        .clk   (i_rd_clk),
        .rst_n (i_rd_rstn),
        .ptr   (wptr),
        .ptr2  (wrptr2)
    );

    rptr_empty #(
        .DEPTH     (DEPTH),
        .PEMPTY_TH (PEMPTY_TH)
    ) u_rptr_empty (
        .rclk      (i_rd_clk),
        .rrst_n    (i_rd_rstn),
        .rinc      (rinc),
        .rempty    (o_rd_empty),
        .aempty    (o_rd_aempty),
        .pempty    (o_rd_pempty),
        .raddr     (raddr),
        .rptr      (rptr),
        .wrptr2    (wrptr2),
        .o_rd_depth(o_rd_depth)
    );

endmodule
